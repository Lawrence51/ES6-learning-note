let命令用于声明，但是只在相应的代码块有效，可用在for循环中(微信开发中两个选项有用到)
for (let i = 0; i < 10; i++) {
  // ...
}
下面的代码如果使用var，最后输出的是10。
var a = [];
for (var i = 0; i < 10; i++) {
  a[i] = function () {
    console.log(i);
  };
}
a[6](); // 10

这是因为var声明的在此处相当于全局变量，之后遍历循环的时候，内部要console的这个i指向的是全局的i。

for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。
for (let i = 0; i < 3; i++) {
  let i = 'abc';
  console.log(i);
}
// abc
// abc
// abc

上面代码正确运行，输出了 3 次abc。这表明函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域。

2、不存在变量提升 
参考之前var的变量声明。let没有

3、暂时性死区
只要块级作用域内存在let，则所声明的变量就绑定此区域，不再受外部影响
如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）

4、不允许重复声明
let不允许在相同作用域内，重复声明同一个变量。

5、块级作用域
代码块之外，无法访问 "{}"类似于这种


二、块级作用域与函数声明
ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。
还有一个需要注意的地方。ES6 的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。

do 表达式
本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值
let x = do{
  let t = f();
  t * t + 1;
}
三、const命令
基本用法
const声明一个只读的变量，一旦声明，常亮的值就不能改变。

const PI = 2.13;
PI // 2.13
PI = 3 //报错
const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。

const保证不变是指变量指向的那个内存地址不得改动。简单类型的数据，值就在那个地址保存，但是针对对象、数组等相对复杂的数据，则无法保证数据结构变化。例：
const foo = {};

//为foo添加一个属性，可以成功
foo.prop = 123;
foo .prop//123
//将foo指向另一个对象，就会报错
foo = {};//报错


